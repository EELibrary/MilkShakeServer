--- ../src-base/minecraft/net/minecraft/server/management/PlayerChunkMap.java
+++ ../src-work/minecraft/net/minecraft/server/management/PlayerChunkMap.java
@@ -1,18 +1,26 @@
 package net.minecraft.server.management;
 
+import catserver.server.AsyncCatcher;
 import com.google.common.base.Predicate;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
+import gg.eilsapgroup.milkshake.MKConfig;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.Nullable;
+
+import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
@@ -20,6 +28,7 @@
 import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.chunk.Chunk;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 
 public class PlayerChunkMap
 {
@@ -38,12 +47,12 @@
         }
     };
     private final WorldServer world;
-    private final List<EntityPlayerMP> players = Lists.<EntityPlayerMP>newArrayList();
+    private final List<EntityPlayerMP> players = new ConcurrentArrayList<>();
     private final Long2ObjectMap<PlayerChunkMapEntry> entryMap = new Long2ObjectOpenHashMap<PlayerChunkMapEntry>(4096);
-    private final Set<PlayerChunkMapEntry> dirtyEntries = Sets.<PlayerChunkMapEntry>newHashSet();
-    private final List<PlayerChunkMapEntry> pendingSendToPlayers = Lists.<PlayerChunkMapEntry>newLinkedList();
-    private final List<PlayerChunkMapEntry> entriesWithoutChunks = Lists.<PlayerChunkMapEntry>newLinkedList();
-    private final List<PlayerChunkMapEntry> entries = Lists.<PlayerChunkMapEntry>newArrayList();
+    private final Set<PlayerChunkMapEntry> dirtyEntries = ConcurrentHashMap.newKeySet();
+    private final List<PlayerChunkMapEntry> pendingSendToPlayers = new CopyOnWriteArrayList<>();;
+    private final List<PlayerChunkMapEntry> entriesWithoutChunks = new CopyOnWriteArrayList<>();;
+    private final List<PlayerChunkMapEntry> entries = new ConcurrentArrayList<>();
     private int playerViewRadius;
     private long previousTotalWorldTime;
     private boolean sortMissingChunks = true;
@@ -52,7 +61,7 @@
     public PlayerChunkMap(WorldServer serverWorld)
     {
         this.world = serverWorld;
-        this.setPlayerViewRadius(serverWorld.getMinecraftServer().getPlayerList().getViewDistance());
+        this.setPlayerViewRadius(serverWorld.spigotConfig.viewDistance); // Spigot
     }
 
     public WorldServer getWorldServer()
@@ -103,6 +112,8 @@
         };
     }
 
+    private final ForkJoinPool chunkExecutor2 = new ForkJoinPool(Runtime.getRuntime().availableProcessors(), MKConfig.serverWorkerFactory,null,true);
+
     public void tick()
     {
         long i = this.world.getTotalWorldTime();
@@ -111,20 +122,46 @@
         {
             this.previousTotalWorldTime = i;
 
-            for (int j = 0; j < this.entries.size(); ++j)
-            {
-                PlayerChunkMapEntry playerchunkmapentry = this.entries.get(j);
-                playerchunkmapentry.update();
-                playerchunkmapentry.updateChunkInhabitedTime();
+            final CountDownLatch latch = new CountDownLatch(this.entries.size());
+            for (PlayerChunkMapEntry playerchunkmapentry : this.entries) {
+                chunkExecutor2.execute(()->{
+                    AsyncCatcher.server_workers.add(Thread.currentThread());
+                    try {
+                        playerchunkmapentry.update();
+                        playerchunkmapentry.updateChunkInhabitedTime();
+                    }finally {
+                        latch.countDown();
+                        AsyncCatcher.server_workers.remove(Thread.currentThread());
+                    }
+                });
             }
+            try {
+                latch.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
         }
 
         if (!this.dirtyEntries.isEmpty())
         {
+            final CountDownLatch latch2 = new CountDownLatch(this.dirtyEntries.size());
             for (PlayerChunkMapEntry playerchunkmapentry2 : this.dirtyEntries)
             {
-                playerchunkmapentry2.update();
+                chunkExecutor2.execute(()->{
+                    AsyncCatcher.server_workers.add(Thread.currentThread());
+                    try {
+                        playerchunkmapentry2.update();
+                    }finally {
+                        latch2.countDown();
+                        AsyncCatcher.server_workers.remove(Thread.currentThread());
+                    }
+                });
             }
+            try {
+                latch2.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
 
             this.dirtyEntries.clear();
         }
@@ -132,81 +169,95 @@
         if (this.sortMissingChunks && i % 4L == 0L)
         {
             this.sortMissingChunks = false;
-            Collections.sort(this.entriesWithoutChunks, new Comparator<PlayerChunkMapEntry>()
-            {
-                public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_)
-                {
-                    return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
-                }
-            });
+            this.entriesWithoutChunks.sort((p_compare_1_, p_compare_2_) -> ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result());
         }
 
         if (this.sortSendToPlayers && i % 4L == 2L)
         {
             this.sortSendToPlayers = false;
-            Collections.sort(this.pendingSendToPlayers, new Comparator<PlayerChunkMapEntry>()
-            {
-                public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_)
-                {
-                    return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
-                }
-            });
+            this.pendingSendToPlayers.sort((p_compare_1_, p_compare_2_) -> ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result());
         }
 
         if (!this.entriesWithoutChunks.isEmpty())
         {
-            long l = System.nanoTime() + 50000000L;
-            int k = 49;
-            Iterator<PlayerChunkMapEntry> iterator = this.entriesWithoutChunks.iterator();
+            AtomicInteger k = new AtomicInteger(49);
 
-            while (iterator.hasNext())
-            {
-                PlayerChunkMapEntry playerchunkmapentry1 = iterator.next();
+            // Spigot start
+            org.spigotmc.SlackActivityAccountant activityAccountant = net.minecraft.server.MinecraftServer.getServerInst().slackActivityAccountant;
+            activityAccountant.startActivity(Math.min(catserver.server.CatServer.getConfig().worldGenMaxTickTime, 18.75) / (18.75 * 2)); // CatServer - 50 * 0.375 = 18.75
+            // Spigot end
+            final CountDownLatch latch3 = new CountDownLatch(this.entriesWithoutChunks.size());
+            for (PlayerChunkMapEntry playerchunkmapentry1 : this.entriesWithoutChunks) {
+                chunkExecutor2.execute(()->{
+                    try {
+                        AsyncCatcher.server_workers.add(Thread.currentThread());
+                        if (playerchunkmapentry1.getChunk() == null) {
+                            if (k.get() < 0 || activityAccountant.activityTimeIsExhausted()) // CatServer
+                            {
+                                return;
+                            }
+                            boolean flag = playerchunkmapentry1.hasPlayerMatching(CAN_GENERATE_CHUNKS);
 
-                if (playerchunkmapentry1.getChunk() == null)
-                {
-                    boolean flag = playerchunkmapentry1.hasPlayerMatching(CAN_GENERATE_CHUNKS);
+                            if (playerchunkmapentry1.providePlayerChunk(flag)) {
+                                this.entriesWithoutChunks.remove(playerchunkmapentry1);
 
-                    if (playerchunkmapentry1.providePlayerChunk(flag))
-                    {
-                        iterator.remove();
+                                if (playerchunkmapentry1.sendToPlayers()) {
+                                    this.pendingSendToPlayers.remove(playerchunkmapentry1);
+                                }
 
-                        if (playerchunkmapentry1.sendToPlayers())
-                        {
-                            this.pendingSendToPlayers.remove(playerchunkmapentry1);
+                                k.decrementAndGet();
+                            }
+                        } else {
+                            if (k.get() < 0 || activityAccountant.activityTimeIsExhausted()) // CatServer
+                            {
+                                return;
+                            }
+                            // CraftBukkit - SPIGOT-2891: remove once chunk has been provided
+                            this.entriesWithoutChunks.remove(playerchunkmapentry1);
                         }
-
-                        --k;
-
-                        if (k < 0 || System.nanoTime() > l)
-                        {
-                            break;
-                        }
+                    }finally {
+                        latch3.countDown();
+                        AsyncCatcher.server_workers.remove(Thread.currentThread());
                     }
-                }
+                });
             }
+            try {
+                latch3.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+
+            activityAccountant.endActivity(); // Spigot
         }
 
         if (!this.pendingSendToPlayers.isEmpty())
         {
-            int i1 = 81;
-            Iterator<PlayerChunkMapEntry> iterator1 = this.pendingSendToPlayers.iterator();
+            AtomicInteger i1 = new AtomicInteger(81);
 
-            while (iterator1.hasNext())
-            {
-                PlayerChunkMapEntry playerchunkmapentry3 = iterator1.next();
+            final CountDownLatch latch4 = new CountDownLatch(this.pendingSendToPlayers.size());
 
-                if (playerchunkmapentry3.sendToPlayers())
-                {
-                    iterator1.remove();
-                    --i1;
-
-                    if (i1 < 0)
-                    {
-                        break;
+            for (PlayerChunkMapEntry playerchunkmapentry3 : this.pendingSendToPlayers) {
+                chunkExecutor2.execute(()->{
+                    AsyncCatcher.server_workers.add(Thread.currentThread());
+                    try {
+                        if (playerchunkmapentry3.sendToPlayers()) {
+                            if (!(i1.get() < 0)) {
+                                this.pendingSendToPlayers.remove(playerchunkmapentry3);
+                                i1.decrementAndGet();
+                            }
+                        }
+                    }finally {
+                        latch4.countDown();
+                        AsyncCatcher.server_workers.remove(Thread.currentThread());
                     }
-                }
+                });
             }
+
+            try {
+                latch4.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
         }
 
         if (this.players.isEmpty())
@@ -223,24 +274,33 @@
     public boolean contains(int chunkX, int chunkZ)
     {
         long i = getIndex(chunkX, chunkZ);
-        return this.entryMap.get(i) != null;
+        synchronized (this.entryMap){
+            return this.entryMap.get(i) != null;
+        }
     }
 
     @Nullable
     public PlayerChunkMapEntry getEntry(int x, int z)
     {
-        return (PlayerChunkMapEntry)this.entryMap.get(getIndex(x, z));
+        synchronized (this.entryMap) {
+          return (PlayerChunkMapEntry) this.entryMap.get(getIndex(x, z));
+        }
     }
 
     private PlayerChunkMapEntry getOrCreateEntry(int chunkX, int chunkZ)
     {
         long i = getIndex(chunkX, chunkZ);
-        PlayerChunkMapEntry playerchunkmapentry = (PlayerChunkMapEntry)this.entryMap.get(i);
+        PlayerChunkMapEntry playerchunkmapentry;
+        synchronized (this.entryMap){
+            playerchunkmapentry = this.entryMap.get(i);
+        }
 
         if (playerchunkmapentry == null)
         {
             playerchunkmapentry = new PlayerChunkMapEntry(this, chunkX, chunkZ);
-            this.entryMap.put(i, playerchunkmapentry);
+            synchronized (this.entryMap) {
+                this.entryMap.put(i, playerchunkmapentry);
+            }
             this.entries.add(playerchunkmapentry);
 
             if (playerchunkmapentry.getChunk() == null)
@@ -257,8 +317,17 @@
         return playerchunkmapentry;
     }
 
+    public final boolean isChunkInUse(int x, int z) {
+        PlayerChunkMapEntry pi = getEntry(x, z);
+        if (pi != null) {
+            return (pi.players.size() > 0);
+        }
+        return false;
+    }
+
     public void markBlockForUpdate(BlockPos pos)
     {
+        if (catserver.server.AsyncCatcher.checkAndPostPrimaryThread("update block", () -> markBlockForUpdate(pos))) return; // CatServer
         int i = pos.getX() >> 4;
         int j = pos.getZ() >> 4;
         PlayerChunkMapEntry playerchunkmapentry = this.getEntry(i, j);
@@ -276,14 +345,22 @@
         player.managedPosX = player.posX;
         player.managedPosZ = player.posZ;
 
+        List<ChunkPos> chunkList = new LinkedList<>();
+
         for (int k = i - this.playerViewRadius; k <= i + this.playerViewRadius; ++k)
         {
             for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; ++l)
             {
-                this.getOrCreateEntry(k, l).addPlayer(player);
+                // this.getOrCreateEntry(k, l).addPlayer(player);
+                chunkList.add(new ChunkPos(k, l));
             }
         }
 
+        Collections.sort(chunkList, new ChunkCoordComparator(player));
+        for (ChunkPos pair : chunkList) {
+            this.getOrCreateEntry(pair.x, pair.z).addPlayer(player);
+        }
+
         this.players.add(player);
         this.markSortPending();
     }
@@ -341,6 +418,8 @@
             int j1 = i - k;
             int k1 = j - l;
 
+            List<ChunkPos> chunksToLoad = new LinkedList<>();
+
             if (j1 != 0 || k1 != 0)
             {
                 for (int l1 = i - i1; l1 <= i + i1; ++l1)
@@ -349,7 +428,8 @@
                     {
                         if (!this.overlaps(l1, i2, k, l, i1))
                         {
-                            this.getOrCreateEntry(l1, i2).addPlayer(player);
+                            // this.getOrCreateEntry(l1, i2).addPlayer(player);
+                            chunksToLoad.add(new ChunkPos(l1, i2));
                         }
 
                         if (!this.overlaps(l1 - j1, i2 - k1, i, j, i1))
@@ -367,6 +447,12 @@
                 player.managedPosX = player.posX;
                 player.managedPosZ = player.posZ;
                 this.markSortPending();
+                // CraftBukkit start - send nearest chunks first
+                Collections.sort(chunksToLoad, new ChunkCoordComparator(player));
+                for (ChunkPos pair : chunksToLoad) {
+                    this.getOrCreateEntry(pair.x, pair.z).addPlayer(player);
+                }
+                // CraftBukkit end
             }
         }
     }
@@ -443,24 +529,97 @@
 
     public void entryChanged(PlayerChunkMapEntry entry)
     {
+        org.spigotmc.AsyncCatcher.catchOp("Async Player Chunk Add"); // Paper
         this.dirtyEntries.add(entry);
     }
 
     public void removeEntry(PlayerChunkMapEntry entry)
     {
+        org.spigotmc.AsyncCatcher.catchOp("Async Player Chunk Remove"); // Paper
         ChunkPos chunkpos = entry.getPos();
         long i = getIndex(chunkpos.x, chunkpos.z);
         entry.updateChunkInhabitedTime();
-        this.entryMap.remove(i);
+        synchronized (this.entryMap) {
+            this.entryMap.remove(i);
+        }
         this.entries.remove(entry);
         this.dirtyEntries.remove(entry);
         this.pendingSendToPlayers.remove(entry);
         this.entriesWithoutChunks.remove(entry);
         Chunk chunk = entry.getChunk();
 
-        if (chunk != null)
+        if (false && chunk != null) // CatServer - use craftbukkit timing unload chunk
         {
             this.getWorldServer().getChunkProvider().queueUnload(chunk);
         }
     }
+
+    // CraftBukkit start - Sorter to load nearby chunks first
+    private static class ChunkCoordComparator implements java.util.Comparator<ChunkPos> {
+        private int x;
+        private int z;
+
+        public ChunkCoordComparator (EntityPlayer entityplayer) {
+            x = (int) entityplayer.posX >> 4;
+            z = (int) entityplayer.posZ >> 4;
+        }
+
+        // CatServer start
+        public ChunkCoordComparator(int x, int z) {
+            this.x = x;
+            this.z = z;
+        }
+        // CatServer end
+
+        public int compare(ChunkPos a, ChunkPos b) {
+            if (a.equals(b)) {
+                return 0;
+            }
+
+            // Subtract current position to set center point
+            int ax = a.x - this.x;
+            int az = a.z - this.z;
+            int bx = b.x - this.x;
+            int bz = b.z - this.z;
+
+            int result = ((ax - bx) * (ax + bx)) + ((az - bz) * (az + bz));
+            if (result != 0) {
+                return result;
+            }
+
+            if (ax < 0) {
+                if (bx < 0) {
+                    return bz - az;
+                } else {
+                    return -1;
+                }
+            } else {
+                if (bx < 0) {
+                    return 1;
+                } else {
+                    return az - bz;
+                }
+            }
+        }
+    }
+    // CraftBukkit end
+
+    // CatServer start
+    public void prepareForAsync(int chunkX, int chunkZ) {
+        List<ChunkPos> chunkList = new LinkedList<>();
+
+        for (int k = chunkX - this.playerViewRadius; k <= chunkX + this.playerViewRadius; ++k) {
+            for (int l = chunkZ - this.playerViewRadius; l <= chunkZ + this.playerViewRadius; ++l) {
+                chunkList.add(new ChunkPos(k, l));
+            }
+        }
+
+        Collections.sort(chunkList, new ChunkCoordComparator(chunkX, chunkZ));
+        for (ChunkPos pair : chunkList) {
+            this.getOrCreateEntry(pair.x, pair.z);
+        }
+
+        this.markSortPending();
+    }
+    // CatServer end
 }
